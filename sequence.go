// Package dateseq creates a sequence series of daily dates.
package dateseq

import (
	"sort"
	"time"
)

// Sequence represents a slice of dates.
type Sequence struct {
	seq      []time.Time
	exclude  []time.Time
	fromDate time.Time
	toDate   time.Time
	steps    int
	weekends bool
}

// New returns a Sequence ready for use.
func New() Sequence {
	return Sequence{weekends: true}
}

// IncludeWeekends includes Saturday and Sunday back into the sequence.
func (s Sequence) IncludeWeekends() Sequence {
	s.weekends = true
	s.seq = addWeekendToDateList(s.seq)

	return s
}

// ExcludeWeekends excludes Saturday and Sunday from the sequence.
// Weekends are included by default.
func (s Sequence) ExcludeWeekends() Sequence {
	s.weekends = false
	s.seq = removeWeekendFromDateList(s.seq)

	return s
}

// Exclude excludes a list of dates from the sequence.
// This shortens the sequence by the number of excluded dates.
// If steps is set, the sequence fill be filled up by the number of excluded dates.
func (s Sequence) Exclude(list []string) Sequence {
	// list is empty
	if len(list) == 0 {
		return s
	}

	// parse list of dates, sort and set exclude field
	var exclude []time.Time
	for _, v := range list {
		t, _ := time.Parse("2006-01-02", v)
		exclude = append(exclude, t)
	}
	s.exclude = sortAsc(exclude)

	// sequence is empty
	if s.seq == nil {
		return s
	}

	for i := 0; i < len(s.seq); i++ {
		date := s.seq[i]

		for _, ex := range exclude {
			if date == ex {
				s.seq = append(s.seq[:i], s.seq[i+1:]...)
				i-- // decrease index since slice is shifted
			}
		}
	}

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// Steps creates a date sequence with the specified length of days ending now.
// The signing of steps will determine, if the sequence goes back of forward in time.
// Calls to Steps will reset the sequence slice to nil before generating an new sequence.
func (s Sequence) Steps(i int) Sequence {
	s.steps = i

	// get current date
	t, _ := time.Parse("2006-01-02", time.Now().Format("2006-01-02"))

	// reset the seqeuence slice
	if len(s.seq) != 0 {
		s.seq = nil
	}

	switch {
	case i > 0:
		for k := 0; k < i; k++ {
			if !s.weekends {
				if (t.Weekday() == 0) || (t.Weekday() == 6) {
					t = t.AddDate(0, 0, +1)
					k--
					continue
				}
			}

			s.seq = append(s.seq, t)
			t = t.AddDate(0, 0, +1)
		}

	case i < 0:
		for k := 0; k > i; k-- {
			if !s.weekends {
				if (t.Weekday() == 0) || (t.Weekday() == 6) {
					t = t.AddDate(0, 0, -1)
					k++
					continue
				}
			}

			s.seq = append(s.seq, t)
			t = t.AddDate(0, 0, -1)
		}
	default: // i == 0
	}

	s.seq = sortAsc(s.seq)

	return s
}

// FromDate starts the sequence from a given date.
// If the sequence is alredy generated by Steps(), it will truncate the sequence
// from that date. The direction back or forward in time will be determined by the sign of steps.
// If the sequence is not already generated, this methof will generate it.
func (s Sequence) FromDate(date string) Sequence {
	// parse date and set fromDate field
	t, _ := time.Parse("2006-01-02", date)
	s.fromDate = t

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// ToDate starts the sequence that it ends at a given date.
func (s Sequence) ToDate(date string) Sequence {
	// parse date and set toDate field
	t, _ := time.Parse("2006-01-02", date)
	s.toDate = t

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// SortAsc sorts a slice of dates in ascending order, i.e. 2006-01-02 comes before 2006-01-03
func (s Sequence) SortAsc() Sequence {
	s.seq = sortAsc(s.seq)

	return s
}

// SortDesc sorts a slice of dates in descending order, i.e. 2006-01-01 comes after 2006-01-02
func (s Sequence) SortDesc() Sequence {
	s.seq = sortDesc(s.seq)

	return s
}

// Sequence returns the sequence slice.
func (s Sequence) Sequence() []time.Time {
	return s.seq
}

// String returns the sequence as a slice with a simple string repesentation
// of the dates in the format YYYY-MM-DD.
func (s Sequence) String() []string {
	var strings = make([]string, len(s.seq))

	for k, v := range s.seq {
		strings[k] = v.Format("2006-01-02")
	}

	return strings
}

// Format returns the sequence as a slice with a string repesentation of the date in the specified layout.
func (s Sequence) Format(layout string) []string {
	var strings = make([]string, len(s.seq))

	for k, v := range s.seq {
		strings[k] = v.Format(layout)
	}

	return strings
}

func removeWeekendFromDateList(list []time.Time) []time.Time {
	if len(list) == 0 {
		return list
	}

	for i := 0; i < len(list); i++ {
		date := list[i]

		if (date.Weekday() == 0) || (date.Weekday() == 6) {
			list = append(list[:i], list[i+1:]...)
			i-- // decrease index since slice is shifted
		}
	}
	return list
}

func addWeekendToDateList(list []time.Time) []time.Time {
	if len(list) == 0 {
		return list
	}
	// lets sort that input list
	list = sortAsc(list)

	for i := 0; i < len(list); i++ {
		current := list[i]

		// if current day is a Friday and the next day is a Monday, add the weekend
		if (current.Weekday() == 5) && (list[i+1].Weekday() == 1) {
			// set saturday and sunday
			sat := current.AddDate(0, 0, +1)
			sun := current.AddDate(0, 0, +2)

			// createw an new list an spilt the old list into before and after
			newList := []time.Time{}
			listBeforeWeekend := append([]time.Time(nil), list[:i+1]...)
			listAfterWeekend := append([]time.Time(nil), list[i+1:]...)

			// build new list
			newList = append(listBeforeWeekend, sat, sun)
			newList = append(newList, listAfterWeekend...)
			i = i + 2 // increase index since slice is shifted
			list = newList
		}

	}
	return list
}

func sortAsc(slice []time.Time) []time.Time {
	sort.Slice(slice, func(i, j int) bool {
		d1 := slice[i]
		d2 := slice[j]

		// sort by date
		return d1.Before(d2)
	})

	return slice
}

func sortDesc(slice []time.Time) []time.Time {
	sort.Slice(slice, func(i, j int) bool {
		d1 := slice[i]
		d2 := slice[j]

		// sort by date
		return d2.Before(d1)
	})

	return slice
}
