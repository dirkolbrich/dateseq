// Package dateseq creates a sequence series of daily dates.
package dateseq

import (
	"sort"
	"time"
)

// Sequence represents a slice of dates.
type Sequence struct {
	seq      []time.Time
	exclude  []time.Time
	fromDate time.Time
	toDate   time.Time
	steps    int
	weekends bool
}

// New returns a Sequence ready for use.
func New() Sequence {
	return Sequence{weekends: true}
}

// IncludeWeekends includes Saturday and Sunday into the sequence.
func (s Sequence) IncludeWeekends() Sequence {
	s.weekends = true
	return s
}

// ExcludeWeekends excludes Saturday and Sunday from the sequence.
// Weekends are included by default.
func (s Sequence) ExcludeWeekends() Sequence {
	s.weekends = false
	return s
}

// Exclude excludes a list of dates from the sequence.
// This shortens the sequence by the number of excluded dates.
// If steps is set, the sequence fill be filled up by the number of excluded dates.
func (s Sequence) Exclude(list []string) Sequence {
	// list is empty
	if len(list) == 0 {
		return s
	}

	// parse list of dates, sort and set exclude field
	var exclude []time.Time
	for _, v := range list {
		t, _ := time.Parse("2006-01-02", v)
		exclude = append(exclude, t)
	}
	s.exclude = sortAsc(exclude)

	// sequence is empty
	if s.seq == nil {
		return s
	}

	for i := 0; i < len(s.seq); i++ {
		date := s.seq[i]

		for _, ex := range exclude {
			if date == ex {
				s.seq = append(s.seq[:i], s.seq[i+1:]...)
				i-- // decrease index since slice is shifted
			}
		}
	}

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// Steps creates a date sequence with the specified length of days ending now.
// The signing of steps will determine, if the sequence goes back of forward in time.
// Calls to Steps will reset the sequence slice to nil before generating an new sequence.
func (s Sequence) Steps(i int) Sequence {
	s.steps = i

	// get current date
	t, _ := time.Parse("2006-01-02", time.Now().Format("2006-01-02"))

	// reset the seqeuence slice
	if len(s.seq) != 0 {
		s.seq = nil
	}

	switch {
	case i > 0:
		for k := 0; k < i; k++ {
			if !s.weekends {
				if (t.Weekday() == 0) || (t.Weekday() == 6) {
					t = t.AddDate(0, 0, +1)
					k--
					continue
				}
			}

			s.seq = append(s.seq, t)
			t = t.AddDate(0, 0, +1)
		}

	case i < 0:
		for k := 0; k > i; k-- {
			if !s.weekends {
				if (t.Weekday() == 0) || (t.Weekday() == 6) {
					t = t.AddDate(0, 0, -1)
					k++
					continue
				}
			}

			s.seq = append(s.seq, t)
			t = t.AddDate(0, 0, -1)
		}
	default: // i == 0
	}

	return s
}

// FromDate starts the sequence from a given date.
// If the sequence is alredy generated by Steps(), it will truncate the sequence
// from that date. The direction back or forward in time will be determined by the sign of steps.
// If the sequence is not already generated, this methof will generate it.
func (s Sequence) FromDate(date string) Sequence {
	// parse date and set fromDate field
	t, _ := time.Parse("2006-01-02", date)
	s.fromDate = t

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// ToDate starts the sequence that it ends at a given date.
func (s Sequence) ToDate(date string) Sequence {
	// parse date and set toDate field
	t, _ := time.Parse("2006-01-02", date)
	s.toDate = t

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// SortAsc sorts a slice of dates in ascending order, i.e. 2006-01-02 comes before 2006-01-03
func (s Sequence) SortAsc() Sequence {
	s.seq = sortAsc(s.seq)

	return s
}

// SortDesc sorts a slice of dates in descending order, i.e. 2006-01-01 comes after 2006-01-02
func (s Sequence) SortDesc() Sequence {
	s.seq = sortDesc(s.seq)

	return s
}

func sortAsc(slice []time.Time) []time.Time {
	sort.Slice(slice, func(i, j int) bool {
		d1 := slice[i]
		d2 := slice[j]

		// sort by date
		return d1.Before(d2)
	})

	return slice
}

func sortDesc(slice []time.Time) []time.Time {
	sort.Slice(slice, func(i, j int) bool {
		d1 := slice[i]
		d2 := slice[j]

		// sort by date
		return d2.Before(d1)
	})

	return slice
}

// Sequence returns the sequence slice.
func (s Sequence) Sequence() []time.Time {
	return s.seq
}

// String returns the sequence as a slice with a simple string repesentation
// of the dates in the format YYYY-MM-DD.
func (s Sequence) String() []string {
	var strings = make([]string, len(s.seq))

	for k, v := range s.seq {
		strings[k] = v.Format("2006-01-02")
	}

	return strings
}

// Format returns the sequence as a slice with a string repesentation of the date in the specified layout.
func (s Sequence) Format(layout string) []string {
	var strings = make([]string, len(s.seq))

	for k, v := range s.seq {
		strings[k] = v.Format(layout)
	}

	return strings
}
