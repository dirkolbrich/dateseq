// Package dateseq creates a sequence series of daily dates.
package dateseq

import (
	"sort"
	"time"
)

// Sequence represents a slice of dates with attached manipulation operations.
type Sequence struct {
	// Now represent the time the sequence is created by default.
	// All date sequence operations reference to this point in time.
	// Now can be set to any point in time.
	Now time.Time

	// From represent a point in time, **from** which all date sequences are directed
	// with default order ascending.
	From time.Time

	// To represents a point in time, **to** which all date sequences are directed
	// with default order ascending.
	To time.Time

	// Weekends signal if weekends are included within the date sequence, default on New() is true.
	Weekends bool

	steps     int
	ascending bool
	seq       []time.Time
	exclude   []time.Time
}

// New returns a Sequence with some sensible default options ready for use.
func New() Sequence {
	now, _ := time.Parse("2006-01-02", time.Now().Format("2006-01-02"))

	return Sequence{
		Now:       now,
		Weekends:  true,
		ascending: true,
	}
}

// IncludeWeekends includes Saturday and Sunday back into the sequence.
func (s Sequence) IncludeWeekends() Sequence {
	s.Weekends = true
	s.seq = addWeekendToSequence(s.seq)

	return s
}

// ExcludeWeekends excludes Saturday and Sunday from the sequence.
// Weekends are included by default.
func (s Sequence) ExcludeWeekends() Sequence {
	s.Weekends = false
	s.seq = removeWeekendFromSequence(s.seq)

	return s
}

// Exclude excludes a list of dates from the sequence.
// This shortens the sequence by the number of excluded dates.
// If steps is set, the sequence fill be filled up by the number of excluded dates.
func (s Sequence) Exclude(list []string) Sequence {
	// list is empty
	if len(list) == 0 {
		return s
	}

	// parse list of dates, sort and set exclude field
	var exclude []time.Time
	for _, v := range list {
		t, _ := time.Parse("2006-01-02", v)
		exclude = append(exclude, t)
	}
	s.exclude = sortAsc(exclude)

	// sequence is empty
	if s.seq == nil {
		return s
	}

	for i := 0; i < len(s.seq); i++ {
		date := s.seq[i]

		for _, ex := range exclude {
			if date == ex {
				s.seq = append(s.seq[:i], s.seq[i+1:]...)
				i-- // decrease index since slice is shifted
			}
		}
	}

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// WithSteps creates a date sequence with the specified length of days.
// The signing of steps will determine, if the sequence goes back or forward in time.
// Calls to WithSteps will reset the sequence slice to nil before generating an new sequence.
func (s Sequence) WithSteps(i int) Sequence {
	s.steps = i

	// get current date
	t := s.Now

	// reset the seqeuence slice
	if len(s.seq) != 0 {
		s.seq = nil
	}

	switch {
	case i > 0:
		for k := 0; k < i; k++ {
			if !s.Weekends {
				if (t.Weekday() == 0) || (t.Weekday() == 6) {
					t = t.AddDate(0, 0, +1)
					k--
					continue
				}
			}

			s.seq = append(s.seq, t)
			t = t.AddDate(0, 0, +1)
		}

	case i < 0:
		for k := 0; k > i; k-- {
			if !s.Weekends {
				if (t.Weekday() == 0) || (t.Weekday() == 6) {
					t = t.AddDate(0, 0, -1)
					k++
					continue
				}
			}

			s.seq = append(s.seq, t)
			t = t.AddDate(0, 0, -1)
		}
	default: // i == 0
	}

	s.seq = sortAsc(s.seq)

	return s
}

// FromDate starts the sequence from a given date.
// If the sequence is alredy generated by Steps(), it will truncate the sequence
// from that date. The direction back or forward in time will be determined by the sign of steps.
// If the sequence is not already generated, this methof will generate it.
func (s Sequence) FromDate(date string) Sequence {
	// validate date string
	if date == "" {
		return s
	}

	// parse date and set From field
	from, _ := time.Parse("2006-01-02", date)
	s.From = from

	// create sequence
	seq := createSequence(from, s.Now)

	switch {
	case from.Before(s.Now): // from before now
		s.seq = seq
	case from.After(s.Now): // from after now
		seq = sortDesc(seq)
		s.seq = seq
	default:
		return s
	}

	return s
}

// ToDate starts the sequence that it ends at a given date.
func (s Sequence) ToDate(date string) Sequence {
	// validate date string
	if date == "" {
		return s
	}

	// parse date and set To field
	to, _ := time.Parse("2006-01-02", date)
	s.To = to

	// create sequence
	seq := createSequence(to, s.Now)

	switch {
	case to.Before(s.Now): // from before now
		s.seq = seq
	case to.After(s.Now): // from after now
		seq = sortAsc(seq)
		s.seq = seq
	default:
		return s
	}

	// steps are set
	if s.steps != 0 {
		// fill up the sequence
	}

	return s
}

// SortAsc sorts a slice of dates in ascending order, i.e. 2006-01-02 comes before 2006-01-03
func (s Sequence) SortAsc() Sequence {
	s.ascending = true
	s.seq = sortAsc(s.seq)

	return s
}

// SortDesc sorts a slice of dates in descending order, i.e. 2006-01-01 comes after 2006-01-02
func (s Sequence) SortDesc() Sequence {
	s.ascending = false
	s.seq = sortDesc(s.seq)

	return s
}

// Sequence returns the current sequence slice.
func (s Sequence) Sequence() []time.Time {
	return s.seq
}

// String returns the sequence as a slice with a simple string repesentation
// of the dates in the format YYYY-MM-DD.
func (s Sequence) String() []string {
	var strings = make([]string, len(s.seq))

	for k, v := range s.seq {
		strings[k] = v.Format("2006-01-02")
	}

	return strings
}

// Format returns the sequence as a slice with a string repesentation of the date in the specified layout.
func (s Sequence) Format(layout string) []string {
	var strings = make([]string, len(s.seq))

	for k, v := range s.seq {
		strings[k] = v.Format(layout)
	}

	return strings
}

func createSequence(t1, t2 time.Time) []time.Time {
	var sequence []time.Time

	// order dates
	if t2.Before(t1) {
		temp := t2
		t2 = t1
		t1 = temp
	}

	// calculate difference between t1 and t2 in days
	diff := int(t2.Sub(t1).Hours() / 24)

	for i := 0; i <= diff; i++ {
		sequence = append(sequence, t1)
		t1 = t1.AddDate(0, 0, +1)
	}

	return sequence
}

func removeWeekendFromSequence(list []time.Time) []time.Time {
	if len(list) == 0 {
		return list
	}

	for i := 0; i < len(list); i++ {
		date := list[i]

		if (date.Weekday() == 0) || (date.Weekday() == 6) {
			list = append(list[:i], list[i+1:]...)
			i-- // decrease index since slice is shifted
		}
	}
	return list
}

func addWeekendToSequence(list []time.Time) []time.Time {
	if len(list) == 0 {
		return list
	}
	// lets sort that input list
	list = sortAsc(list)

	for i := 0; i < len(list); i++ {
		current := list[i]

		// if current day is a Friday and the next day is a Monday, add the weekend
		if (current.Weekday() == 5) && (list[i+1].Weekday() == 1) {
			// set saturday and sunday
			sat := current.AddDate(0, 0, +1)
			sun := current.AddDate(0, 0, +2)

			// createw an new list an spilt the old list into before and after
			newList := []time.Time{}
			listBeforeWeekend := append([]time.Time(nil), list[:i+1]...)
			listAfterWeekend := append([]time.Time(nil), list[i+1:]...)

			// build new list
			newList = append(listBeforeWeekend, sat, sun)
			newList = append(newList, listAfterWeekend...)
			i = i + 2 // increase index since slice is shifted
			list = newList
		}

	}
	return list
}

// sort a slice of time.Time ascending
func sortAsc(slice []time.Time) []time.Time {
	sort.Slice(slice, func(i, j int) bool {
		d1 := slice[i]
		d2 := slice[j]

		// sort by date
		return d1.Before(d2)
	})

	return slice
}

// sort a slice of time.Time descending
func sortDesc(slice []time.Time) []time.Time {
	sort.Slice(slice, func(i, j int) bool {
		d1 := slice[i]
		d2 := slice[j]

		// sort by date
		return d2.Before(d1)
	})

	return slice
}
